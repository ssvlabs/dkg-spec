// Code generated by fastssz. DO NOT EDIT.
// Hash: 1e8eb918c8f16e00081406b415634ffed29fab2b6712ec9e2fc407aceed13d79
// Version: 0.1.3
package spec

import (
	ssz "github.com/ferranbt/fastssz"
)

// MarshalSSZ ssz marshals the Operator object
func (o *Operator) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(o)
}

// MarshalSSZTo ssz marshals the Operator object to a target array
func (o *Operator) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(12)

	// Field (0) 'ID'
	dst = ssz.MarshalUint64(dst, o.ID)

	// Offset (1) 'PubKey'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(o.PubKey)

	// Field (1) 'PubKey'
	if size := len(o.PubKey); size > 2048 {
		err = ssz.ErrBytesLengthFn("Operator.PubKey", size, 2048)
		return
	}
	dst = append(dst, o.PubKey...)

	return
}

// UnmarshalSSZ ssz unmarshals the Operator object
func (o *Operator) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 12 {
		return ssz.ErrSize
	}

	tail := buf
	var o1 uint64

	// Field (0) 'ID'
	o.ID = ssz.UnmarshallUint64(buf[0:8])

	// Offset (1) 'PubKey'
	if o1 = ssz.ReadOffset(buf[8:12]); o1 > size {
		return ssz.ErrOffset
	}

	if o1 < 12 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (1) 'PubKey'
	{
		buf = tail[o1:]
		if len(buf) > 2048 {
			return ssz.ErrBytesLength
		}
		if cap(o.PubKey) == 0 {
			o.PubKey = make([]byte, 0, len(buf))
		}
		o.PubKey = append(o.PubKey, buf...)
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Operator object
func (o *Operator) SizeSSZ() (size int) {
	size = 12

	// Field (1) 'PubKey'
	size += len(o.PubKey)

	return
}

// HashTreeRoot ssz hashes the Operator object
func (o *Operator) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(o)
}

// HashTreeRootWith ssz hashes the Operator object with a hasher
func (o *Operator) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'ID'
	hh.PutUint64(o.ID)

	// Field (1) 'PubKey'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(o.PubKey))
		if byteLen > 2048 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(o.PubKey)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (2048+31)/32)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the Operator object
func (o *Operator) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(o)
}

// MarshalSSZ ssz marshals the Init object
func (i *Init) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(i)
}

// MarshalSSZTo ssz marshals the Init object to a target array
func (i *Init) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(48)

	// Offset (0) 'Operators'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(i.Operators); ii++ {
		offset += 4
		offset += i.Operators[ii].SizeSSZ()
	}

	// Field (1) 'T'
	dst = ssz.MarshalUint64(dst, i.T)

	// Offset (2) 'WithdrawalCredentials'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(i.WithdrawalCredentials)

	// Field (3) 'Fork'
	dst = append(dst, i.Fork[:]...)

	// Field (4) 'Owner'
	dst = append(dst, i.Owner[:]...)

	// Field (5) 'Nonce'
	dst = ssz.MarshalUint64(dst, i.Nonce)

	// Field (0) 'Operators'
	if size := len(i.Operators); size > 13 {
		err = ssz.ErrListTooBigFn("Init.Operators", size, 13)
		return
	}
	{
		offset = 4 * len(i.Operators)
		for ii := 0; ii < len(i.Operators); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += i.Operators[ii].SizeSSZ()
		}
	}
	for ii := 0; ii < len(i.Operators); ii++ {
		if dst, err = i.Operators[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (2) 'WithdrawalCredentials'
	if size := len(i.WithdrawalCredentials); size > 32 {
		err = ssz.ErrBytesLengthFn("Init.WithdrawalCredentials", size, 32)
		return
	}
	dst = append(dst, i.WithdrawalCredentials...)

	return
}

// UnmarshalSSZ ssz unmarshals the Init object
func (i *Init) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 48 {
		return ssz.ErrSize
	}

	tail := buf
	var o0, o2 uint64

	// Offset (0) 'Operators'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 < 48 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (1) 'T'
	i.T = ssz.UnmarshallUint64(buf[4:12])

	// Offset (2) 'WithdrawalCredentials'
	if o2 = ssz.ReadOffset(buf[12:16]); o2 > size || o0 > o2 {
		return ssz.ErrOffset
	}

	// Field (3) 'Fork'
	copy(i.Fork[:], buf[16:20])

	// Field (4) 'Owner'
	copy(i.Owner[:], buf[20:40])

	// Field (5) 'Nonce'
	i.Nonce = ssz.UnmarshallUint64(buf[40:48])

	// Field (0) 'Operators'
	{
		buf = tail[o0:o2]
		num, err := ssz.DecodeDynamicLength(buf, 13)
		if err != nil {
			return err
		}
		i.Operators = make([]*Operator, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if i.Operators[indx] == nil {
				i.Operators[indx] = new(Operator)
			}
			if err = i.Operators[indx].UnmarshalSSZ(buf); err != nil {
				return err
			}
			return nil
		})
		if err != nil {
			return err
		}
	}

	// Field (2) 'WithdrawalCredentials'
	{
		buf = tail[o2:]
		if len(buf) > 32 {
			return ssz.ErrBytesLength
		}
		if cap(i.WithdrawalCredentials) == 0 {
			i.WithdrawalCredentials = make([]byte, 0, len(buf))
		}
		i.WithdrawalCredentials = append(i.WithdrawalCredentials, buf...)
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Init object
func (i *Init) SizeSSZ() (size int) {
	size = 48

	// Field (0) 'Operators'
	for ii := 0; ii < len(i.Operators); ii++ {
		size += 4
		size += i.Operators[ii].SizeSSZ()
	}

	// Field (2) 'WithdrawalCredentials'
	size += len(i.WithdrawalCredentials)

	return
}

// HashTreeRoot ssz hashes the Init object
func (i *Init) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(i)
}

// HashTreeRootWith ssz hashes the Init object with a hasher
func (i *Init) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Operators'
	{
		subIndx := hh.Index()
		num := uint64(len(i.Operators))
		if num > 13 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range i.Operators {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 13)
	}

	// Field (1) 'T'
	hh.PutUint64(i.T)

	// Field (2) 'WithdrawalCredentials'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(i.WithdrawalCredentials))
		if byteLen > 32 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(i.WithdrawalCredentials)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (32+31)/32)
	}

	// Field (3) 'Fork'
	hh.PutBytes(i.Fork[:])

	// Field (4) 'Owner'
	hh.PutBytes(i.Owner[:])

	// Field (5) 'Nonce'
	hh.PutUint64(i.Nonce)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the Init object
func (i *Init) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(i)
}

// MarshalSSZ ssz marshals the Reshare object
func (r *Reshare) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(r)
}

// MarshalSSZTo ssz marshals the Reshare object to a target array
func (r *Reshare) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(108)

	// Field (0) 'ValidatorPubKey'
	if size := len(r.ValidatorPubKey); size != 48 {
		err = ssz.ErrBytesLengthFn("Reshare.ValidatorPubKey", size, 48)
		return
	}
	dst = append(dst, r.ValidatorPubKey...)

	// Offset (1) 'OldOperators'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(r.OldOperators); ii++ {
		offset += 4
		offset += r.OldOperators[ii].SizeSSZ()
	}

	// Offset (2) 'NewOperators'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(r.NewOperators); ii++ {
		offset += 4
		offset += r.NewOperators[ii].SizeSSZ()
	}

	// Field (3) 'OldT'
	dst = ssz.MarshalUint64(dst, r.OldT)

	// Field (4) 'NewT'
	dst = ssz.MarshalUint64(dst, r.NewT)

	// Field (5) 'Fork'
	dst = append(dst, r.Fork[:]...)

	// Offset (6) 'WithdrawalCredentials'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(r.WithdrawalCredentials)

	// Field (7) 'Owner'
	dst = append(dst, r.Owner[:]...)

	// Field (8) 'Nonce'
	dst = ssz.MarshalUint64(dst, r.Nonce)

	// Field (1) 'OldOperators'
	if size := len(r.OldOperators); size > 13 {
		err = ssz.ErrListTooBigFn("Reshare.OldOperators", size, 13)
		return
	}
	{
		offset = 4 * len(r.OldOperators)
		for ii := 0; ii < len(r.OldOperators); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += r.OldOperators[ii].SizeSSZ()
		}
	}
	for ii := 0; ii < len(r.OldOperators); ii++ {
		if dst, err = r.OldOperators[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (2) 'NewOperators'
	if size := len(r.NewOperators); size > 13 {
		err = ssz.ErrListTooBigFn("Reshare.NewOperators", size, 13)
		return
	}
	{
		offset = 4 * len(r.NewOperators)
		for ii := 0; ii < len(r.NewOperators); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += r.NewOperators[ii].SizeSSZ()
		}
	}
	for ii := 0; ii < len(r.NewOperators); ii++ {
		if dst, err = r.NewOperators[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (6) 'WithdrawalCredentials'
	if size := len(r.WithdrawalCredentials); size > 32 {
		err = ssz.ErrBytesLengthFn("Reshare.WithdrawalCredentials", size, 32)
		return
	}
	dst = append(dst, r.WithdrawalCredentials...)

	return
}

// UnmarshalSSZ ssz unmarshals the Reshare object
func (r *Reshare) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 108 {
		return ssz.ErrSize
	}

	tail := buf
	var o1, o2, o6 uint64

	// Field (0) 'ValidatorPubKey'
	if cap(r.ValidatorPubKey) == 0 {
		r.ValidatorPubKey = make([]byte, 0, len(buf[0:48]))
	}
	r.ValidatorPubKey = append(r.ValidatorPubKey, buf[0:48]...)

	// Offset (1) 'OldOperators'
	if o1 = ssz.ReadOffset(buf[48:52]); o1 > size {
		return ssz.ErrOffset
	}

	if o1 < 108 {
		return ssz.ErrInvalidVariableOffset
	}

	// Offset (2) 'NewOperators'
	if o2 = ssz.ReadOffset(buf[52:56]); o2 > size || o1 > o2 {
		return ssz.ErrOffset
	}

	// Field (3) 'OldT'
	r.OldT = ssz.UnmarshallUint64(buf[56:64])

	// Field (4) 'NewT'
	r.NewT = ssz.UnmarshallUint64(buf[64:72])

	// Field (5) 'Fork'
	copy(r.Fork[:], buf[72:76])

	// Offset (6) 'WithdrawalCredentials'
	if o6 = ssz.ReadOffset(buf[76:80]); o6 > size || o2 > o6 {
		return ssz.ErrOffset
	}

	// Field (7) 'Owner'
	copy(r.Owner[:], buf[80:100])

	// Field (8) 'Nonce'
	r.Nonce = ssz.UnmarshallUint64(buf[100:108])

	// Field (1) 'OldOperators'
	{
		buf = tail[o1:o2]
		num, err := ssz.DecodeDynamicLength(buf, 13)
		if err != nil {
			return err
		}
		r.OldOperators = make([]*Operator, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if r.OldOperators[indx] == nil {
				r.OldOperators[indx] = new(Operator)
			}
			if err = r.OldOperators[indx].UnmarshalSSZ(buf); err != nil {
				return err
			}
			return nil
		})
		if err != nil {
			return err
		}
	}

	// Field (2) 'NewOperators'
	{
		buf = tail[o2:o6]
		num, err := ssz.DecodeDynamicLength(buf, 13)
		if err != nil {
			return err
		}
		r.NewOperators = make([]*Operator, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if r.NewOperators[indx] == nil {
				r.NewOperators[indx] = new(Operator)
			}
			if err = r.NewOperators[indx].UnmarshalSSZ(buf); err != nil {
				return err
			}
			return nil
		})
		if err != nil {
			return err
		}
	}

	// Field (6) 'WithdrawalCredentials'
	{
		buf = tail[o6:]
		if len(buf) > 32 {
			return ssz.ErrBytesLength
		}
		if cap(r.WithdrawalCredentials) == 0 {
			r.WithdrawalCredentials = make([]byte, 0, len(buf))
		}
		r.WithdrawalCredentials = append(r.WithdrawalCredentials, buf...)
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Reshare object
func (r *Reshare) SizeSSZ() (size int) {
	size = 108

	// Field (1) 'OldOperators'
	for ii := 0; ii < len(r.OldOperators); ii++ {
		size += 4
		size += r.OldOperators[ii].SizeSSZ()
	}

	// Field (2) 'NewOperators'
	for ii := 0; ii < len(r.NewOperators); ii++ {
		size += 4
		size += r.NewOperators[ii].SizeSSZ()
	}

	// Field (6) 'WithdrawalCredentials'
	size += len(r.WithdrawalCredentials)

	return
}

// HashTreeRoot ssz hashes the Reshare object
func (r *Reshare) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(r)
}

// HashTreeRootWith ssz hashes the Reshare object with a hasher
func (r *Reshare) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'ValidatorPubKey'
	if size := len(r.ValidatorPubKey); size != 48 {
		err = ssz.ErrBytesLengthFn("Reshare.ValidatorPubKey", size, 48)
		return
	}
	hh.PutBytes(r.ValidatorPubKey)

	// Field (1) 'OldOperators'
	{
		subIndx := hh.Index()
		num := uint64(len(r.OldOperators))
		if num > 13 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range r.OldOperators {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 13)
	}

	// Field (2) 'NewOperators'
	{
		subIndx := hh.Index()
		num := uint64(len(r.NewOperators))
		if num > 13 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range r.NewOperators {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 13)
	}

	// Field (3) 'OldT'
	hh.PutUint64(r.OldT)

	// Field (4) 'NewT'
	hh.PutUint64(r.NewT)

	// Field (5) 'Fork'
	hh.PutBytes(r.Fork[:])

	// Field (6) 'WithdrawalCredentials'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(r.WithdrawalCredentials))
		if byteLen > 32 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(r.WithdrawalCredentials)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (32+31)/32)
	}

	// Field (7) 'Owner'
	hh.PutBytes(r.Owner[:])

	// Field (8) 'Nonce'
	hh.PutUint64(r.Nonce)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the Reshare object
func (r *Reshare) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(r)
}

// MarshalSSZ ssz marshals the SignedReshare object
func (s *SignedReshare) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(s)
}

// MarshalSSZTo ssz marshals the SignedReshare object to a target array
func (s *SignedReshare) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(8)

	// Offset (0) 'Reshare'
	dst = ssz.WriteOffset(dst, offset)
	offset += s.Reshare.SizeSSZ()

	// Offset (1) 'Signature'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(s.Signature)

	// Field (0) 'Reshare'
	if dst, err = s.Reshare.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (1) 'Signature'
	if size := len(s.Signature); size > 1536 {
		err = ssz.ErrBytesLengthFn("SignedReshare.Signature", size, 1536)
		return
	}
	dst = append(dst, s.Signature...)

	return
}

// UnmarshalSSZ ssz unmarshals the SignedReshare object
func (s *SignedReshare) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 8 {
		return ssz.ErrSize
	}

	tail := buf
	var o0, o1 uint64

	// Offset (0) 'Reshare'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 < 8 {
		return ssz.ErrInvalidVariableOffset
	}

	// Offset (1) 'Signature'
	if o1 = ssz.ReadOffset(buf[4:8]); o1 > size || o0 > o1 {
		return ssz.ErrOffset
	}

	// Field (0) 'Reshare'
	{
		buf = tail[o0:o1]
		if err = s.Reshare.UnmarshalSSZ(buf); err != nil {
			return err
		}
	}

	// Field (1) 'Signature'
	{
		buf = tail[o1:]
		if len(buf) > 1536 {
			return ssz.ErrBytesLength
		}
		if cap(s.Signature) == 0 {
			s.Signature = make([]byte, 0, len(buf))
		}
		s.Signature = append(s.Signature, buf...)
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the SignedReshare object
func (s *SignedReshare) SizeSSZ() (size int) {
	size = 8

	// Field (0) 'Reshare'
	size += s.Reshare.SizeSSZ()

	// Field (1) 'Signature'
	size += len(s.Signature)

	return
}

// HashTreeRoot ssz hashes the SignedReshare object
func (s *SignedReshare) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(s)
}

// HashTreeRootWith ssz hashes the SignedReshare object with a hasher
func (s *SignedReshare) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Reshare'
	if err = s.Reshare.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (1) 'Signature'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(s.Signature))
		if byteLen > 1536 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(s.Signature)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (1536+31)/32)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the SignedReshare object
func (s *SignedReshare) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(s)
}

// MarshalSSZ ssz marshals the Resign object
func (r *Resign) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(r)
}

// MarshalSSZTo ssz marshals the Resign object to a target array
func (r *Resign) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(84)

	// Field (0) 'ValidatorPubKey'
	if size := len(r.ValidatorPubKey); size != 48 {
		err = ssz.ErrBytesLengthFn("Resign.ValidatorPubKey", size, 48)
		return
	}
	dst = append(dst, r.ValidatorPubKey...)

	// Field (1) 'Fork'
	dst = append(dst, r.Fork[:]...)

	// Offset (2) 'WithdrawalCredentials'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(r.WithdrawalCredentials)

	// Field (3) 'Owner'
	dst = append(dst, r.Owner[:]...)

	// Field (4) 'Nonce'
	dst = ssz.MarshalUint64(dst, r.Nonce)

	// Field (2) 'WithdrawalCredentials'
	if size := len(r.WithdrawalCredentials); size > 32 {
		err = ssz.ErrBytesLengthFn("Resign.WithdrawalCredentials", size, 32)
		return
	}
	dst = append(dst, r.WithdrawalCredentials...)

	return
}

// UnmarshalSSZ ssz unmarshals the Resign object
func (r *Resign) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 84 {
		return ssz.ErrSize
	}

	tail := buf
	var o2 uint64

	// Field (0) 'ValidatorPubKey'
	if cap(r.ValidatorPubKey) == 0 {
		r.ValidatorPubKey = make([]byte, 0, len(buf[0:48]))
	}
	r.ValidatorPubKey = append(r.ValidatorPubKey, buf[0:48]...)

	// Field (1) 'Fork'
	copy(r.Fork[:], buf[48:52])

	// Offset (2) 'WithdrawalCredentials'
	if o2 = ssz.ReadOffset(buf[52:56]); o2 > size {
		return ssz.ErrOffset
	}

	if o2 < 84 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (3) 'Owner'
	copy(r.Owner[:], buf[56:76])

	// Field (4) 'Nonce'
	r.Nonce = ssz.UnmarshallUint64(buf[76:84])

	// Field (2) 'WithdrawalCredentials'
	{
		buf = tail[o2:]
		if len(buf) > 32 {
			return ssz.ErrBytesLength
		}
		if cap(r.WithdrawalCredentials) == 0 {
			r.WithdrawalCredentials = make([]byte, 0, len(buf))
		}
		r.WithdrawalCredentials = append(r.WithdrawalCredentials, buf...)
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Resign object
func (r *Resign) SizeSSZ() (size int) {
	size = 84

	// Field (2) 'WithdrawalCredentials'
	size += len(r.WithdrawalCredentials)

	return
}

// HashTreeRoot ssz hashes the Resign object
func (r *Resign) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(r)
}

// HashTreeRootWith ssz hashes the Resign object with a hasher
func (r *Resign) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'ValidatorPubKey'
	if size := len(r.ValidatorPubKey); size != 48 {
		err = ssz.ErrBytesLengthFn("Resign.ValidatorPubKey", size, 48)
		return
	}
	hh.PutBytes(r.ValidatorPubKey)

	// Field (1) 'Fork'
	hh.PutBytes(r.Fork[:])

	// Field (2) 'WithdrawalCredentials'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(r.WithdrawalCredentials))
		if byteLen > 32 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(r.WithdrawalCredentials)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (32+31)/32)
	}

	// Field (3) 'Owner'
	hh.PutBytes(r.Owner[:])

	// Field (4) 'Nonce'
	hh.PutUint64(r.Nonce)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the Resign object
func (r *Resign) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(r)
}

// MarshalSSZ ssz marshals the SignedResign object
func (s *SignedResign) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(s)
}

// MarshalSSZTo ssz marshals the SignedResign object to a target array
func (s *SignedResign) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(8)

	// Offset (0) 'Resign'
	dst = ssz.WriteOffset(dst, offset)
	offset += s.Resign.SizeSSZ()

	// Offset (1) 'Signature'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(s.Signature)

	// Field (0) 'Resign'
	if dst, err = s.Resign.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (1) 'Signature'
	if size := len(s.Signature); size > 1536 {
		err = ssz.ErrBytesLengthFn("SignedResign.Signature", size, 1536)
		return
	}
	dst = append(dst, s.Signature...)

	return
}

// UnmarshalSSZ ssz unmarshals the SignedResign object
func (s *SignedResign) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 8 {
		return ssz.ErrSize
	}

	tail := buf
	var o0, o1 uint64

	// Offset (0) 'Resign'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 < 8 {
		return ssz.ErrInvalidVariableOffset
	}

	// Offset (1) 'Signature'
	if o1 = ssz.ReadOffset(buf[4:8]); o1 > size || o0 > o1 {
		return ssz.ErrOffset
	}

	// Field (0) 'Resign'
	{
		buf = tail[o0:o1]
		if err = s.Resign.UnmarshalSSZ(buf); err != nil {
			return err
		}
	}

	// Field (1) 'Signature'
	{
		buf = tail[o1:]
		if len(buf) > 1536 {
			return ssz.ErrBytesLength
		}
		if cap(s.Signature) == 0 {
			s.Signature = make([]byte, 0, len(buf))
		}
		s.Signature = append(s.Signature, buf...)
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the SignedResign object
func (s *SignedResign) SizeSSZ() (size int) {
	size = 8

	// Field (0) 'Resign'
	size += s.Resign.SizeSSZ()

	// Field (1) 'Signature'
	size += len(s.Signature)

	return
}

// HashTreeRoot ssz hashes the SignedResign object
func (s *SignedResign) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(s)
}

// HashTreeRootWith ssz hashes the SignedResign object with a hasher
func (s *SignedResign) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Resign'
	if err = s.Resign.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (1) 'Signature'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(s.Signature))
		if byteLen > 1536 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(s.Signature)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (1536+31)/32)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the SignedResign object
func (s *SignedResign) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(s)
}

// MarshalSSZ ssz marshals the Proof object
func (p *Proof) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(p)
}

// MarshalSSZTo ssz marshals the Proof object to a target array
func (p *Proof) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(120)

	// Field (0) 'ValidatorPubKey'
	if size := len(p.ValidatorPubKey); size != 48 {
		err = ssz.ErrBytesLengthFn("Proof.ValidatorPubKey", size, 48)
		return
	}
	dst = append(dst, p.ValidatorPubKey...)

	// Offset (1) 'EncryptedShare'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(p.EncryptedShare)

	// Field (2) 'SharePubKey'
	if size := len(p.SharePubKey); size != 48 {
		err = ssz.ErrBytesLengthFn("Proof.SharePubKey", size, 48)
		return
	}
	dst = append(dst, p.SharePubKey...)

	// Field (3) 'Owner'
	dst = append(dst, p.Owner[:]...)

	// Field (1) 'EncryptedShare'
	if size := len(p.EncryptedShare); size > 512 {
		err = ssz.ErrBytesLengthFn("Proof.EncryptedShare", size, 512)
		return
	}
	dst = append(dst, p.EncryptedShare...)

	return
}

// UnmarshalSSZ ssz unmarshals the Proof object
func (p *Proof) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 120 {
		return ssz.ErrSize
	}

	tail := buf
	var o1 uint64

	// Field (0) 'ValidatorPubKey'
	if cap(p.ValidatorPubKey) == 0 {
		p.ValidatorPubKey = make([]byte, 0, len(buf[0:48]))
	}
	p.ValidatorPubKey = append(p.ValidatorPubKey, buf[0:48]...)

	// Offset (1) 'EncryptedShare'
	if o1 = ssz.ReadOffset(buf[48:52]); o1 > size {
		return ssz.ErrOffset
	}

	if o1 < 120 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (2) 'SharePubKey'
	if cap(p.SharePubKey) == 0 {
		p.SharePubKey = make([]byte, 0, len(buf[52:100]))
	}
	p.SharePubKey = append(p.SharePubKey, buf[52:100]...)

	// Field (3) 'Owner'
	copy(p.Owner[:], buf[100:120])

	// Field (1) 'EncryptedShare'
	{
		buf = tail[o1:]
		if len(buf) > 512 {
			return ssz.ErrBytesLength
		}
		if cap(p.EncryptedShare) == 0 {
			p.EncryptedShare = make([]byte, 0, len(buf))
		}
		p.EncryptedShare = append(p.EncryptedShare, buf...)
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Proof object
func (p *Proof) SizeSSZ() (size int) {
	size = 120

	// Field (1) 'EncryptedShare'
	size += len(p.EncryptedShare)

	return
}

// HashTreeRoot ssz hashes the Proof object
func (p *Proof) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(p)
}

// HashTreeRootWith ssz hashes the Proof object with a hasher
func (p *Proof) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'ValidatorPubKey'
	if size := len(p.ValidatorPubKey); size != 48 {
		err = ssz.ErrBytesLengthFn("Proof.ValidatorPubKey", size, 48)
		return
	}
	hh.PutBytes(p.ValidatorPubKey)

	// Field (1) 'EncryptedShare'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(p.EncryptedShare))
		if byteLen > 512 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(p.EncryptedShare)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (512+31)/32)
	}

	// Field (2) 'SharePubKey'
	if size := len(p.SharePubKey); size != 48 {
		err = ssz.ErrBytesLengthFn("Proof.SharePubKey", size, 48)
		return
	}
	hh.PutBytes(p.SharePubKey)

	// Field (3) 'Owner'
	hh.PutBytes(p.Owner[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the Proof object
func (p *Proof) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(p)
}

// MarshalSSZ ssz marshals the SignedProof object
func (s *SignedProof) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(s)
}

// MarshalSSZTo ssz marshals the SignedProof object to a target array
func (s *SignedProof) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(260)

	// Offset (0) 'Proof'
	dst = ssz.WriteOffset(dst, offset)
	if s.Proof == nil {
		s.Proof = new(Proof)
	}
	offset += s.Proof.SizeSSZ()

	// Field (1) 'Signature'
	if size := len(s.Signature); size != 256 {
		err = ssz.ErrBytesLengthFn("SignedProof.Signature", size, 256)
		return
	}
	dst = append(dst, s.Signature...)

	// Field (0) 'Proof'
	if dst, err = s.Proof.MarshalSSZTo(dst); err != nil {
		return
	}

	return
}

// UnmarshalSSZ ssz unmarshals the SignedProof object
func (s *SignedProof) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 260 {
		return ssz.ErrSize
	}

	tail := buf
	var o0 uint64

	// Offset (0) 'Proof'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 < 260 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (1) 'Signature'
	if cap(s.Signature) == 0 {
		s.Signature = make([]byte, 0, len(buf[4:260]))
	}
	s.Signature = append(s.Signature, buf[4:260]...)

	// Field (0) 'Proof'
	{
		buf = tail[o0:]
		if s.Proof == nil {
			s.Proof = new(Proof)
		}
		if err = s.Proof.UnmarshalSSZ(buf); err != nil {
			return err
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the SignedProof object
func (s *SignedProof) SizeSSZ() (size int) {
	size = 260

	// Field (0) 'Proof'
	if s.Proof == nil {
		s.Proof = new(Proof)
	}
	size += s.Proof.SizeSSZ()

	return
}

// HashTreeRoot ssz hashes the SignedProof object
func (s *SignedProof) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(s)
}

// HashTreeRootWith ssz hashes the SignedProof object with a hasher
func (s *SignedProof) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Proof'
	if err = s.Proof.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (1) 'Signature'
	if size := len(s.Signature); size != 256 {
		err = ssz.ErrBytesLengthFn("SignedProof.Signature", size, 256)
		return
	}
	hh.PutBytes(s.Signature)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the SignedProof object
func (s *SignedProof) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(s)
}
